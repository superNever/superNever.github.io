<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>bubble | supernever</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">bubble</h1><a id="logo" href="/.">supernever</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">bubble</h1><div class="post-meta">Jul 15, 2016<span> | </span><span class="category"><a href="/categories/前端/">前端</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/07/15/bubble/" href="/2016/07/15/bubble/#comments" class="ds-thread-count"></a><div class="post-content"><p>没开篇之前，先讲个小故事。话说昨天小明站在河岸上，看见水里的小鱼吐了一个小气泡，小气泡晃悠晃悠的浮到了水面，<br>“嘭”炸了，结果把水面上的一个小蜻蜓愣是给吓飞了。O(∩_∩)O哈哈哈~ 好笑不。<br><a id="more"></a></p>
<h2 id="事件的发生顺序"><a href="#事件的发生顺序" class="headerlink" title="事件的发生顺序"></a>事件的发生顺序</h2><p>这个问题的起源非常简单，假设你在一个元素中又嵌套了另一个元素<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-----------------------------------</div><div class="line">| element1                        |</div><div class="line">|   -------------------------     |</div><div class="line">|   |element2               |     |</div><div class="line">|   -------------------------     |</div><div class="line">|                                 |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure></p>
<p>：并且两者都有一个onClick事件处理函数(event handler)。如果用户单击元素2，则元素1和元素2的单击事件都会被触发。但是哪一个事件先被触发？哪一个事件处理函数会被首先执行？换句话说，事件的发生顺序到底如何？</p>
<h2 id="两种模型"><a href="#两种模型" class="headerlink" title="两种模型"></a>两种模型</h2><p>Netscape和IE有两种截然不同的处理方法：</p>
<ul>
<li>Netscape主张元素1的事件首先发生，这种事件发生顺序被称为捕获型</li>
<li>微软则保持元素2具有优先权，这种事件顺序被称为冒泡型 </li>
</ul>
<p>这两种事件顺序是截然相反的。Explorer浏览器只支持冒泡事件，Mozilla，Opera7和Konqueror两者都支持。而更古老的opera和iCab两者都不支持(不了解)</p>
<h3 id="捕获型事件"><a href="#捕获型事件" class="headerlink" title="捕获型事件"></a>捕获型事件</h3><p>当你使用捕获型事件时<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">               | |</div><div class="line">---------------| |-----------------</div><div class="line">| element1     | |                |</div><div class="line">|   -----------| |-----------     |</div><div class="line">|   |element2  \ /          |     |</div><div class="line">|   -------------------------     |</div><div class="line">|        Event CAPTURING          |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure></p>
<p>：元素1的事件处理函数首先被触发，元素2的事件处理函数最后被触发</p>
<h3 id="冒泡型事件"><a href="#冒泡型事件" class="headerlink" title="冒泡型事件"></a>冒泡型事件</h3><p>当你使用冒泡型事件时<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">               / \</div><div class="line">---------------| |-----------------</div><div class="line">| element1     | |                |</div><div class="line">|   -----------| |-----------     |</div><div class="line">|   |element2  | |          |     |</div><div class="line">|   -------------------------     |</div><div class="line">|        Event BUBBLING           |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure></p>
<p>：元素2 的处理函数首先被触发，元素1其次</p>
<h3 id="W3C-模型"><a href="#W3C-模型" class="headerlink" title="W3C 模型"></a>W3C 模型</h3><p>W3c明智的在这场争斗中选择了一个择中的方案。任何发生在w3c事件模型中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">                 | |  / \</div><div class="line">-----------------| |--| |-----------------</div><div class="line">| element1       | |  | |                |</div><div class="line">|   -------------| |--| |-----------     |</div><div class="line">|   |element2    \ /  | |          |     |</div><div class="line">|   --------------------------------     |</div><div class="line">|        W3C event model                 |</div><div class="line">------------------------------------------</div></pre></td></tr></table></figure></p>
<p>为一个web开发者，你可以选择是在捕获阶段还是冒泡阶段绑定事件处理函数，这是通过addEventListener()方法实现的，如果这个函数的最后一个参数是true，则在捕获阶段绑定函数，反之false，在冒泡阶段绑定函数。<br>假设你要做的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element1.addEventListener(<span class="string">'click'</span>,<span class="keyword">do</span>Something2,<span class="literal">true</span>)</div><div class="line"></div><div class="line">element2.addEventListener(<span class="string">'click'</span>,<span class="keyword">do</span>Something,<span class="literal">false</span>)</div></pre></td></tr></table></figure></p>
<p>如果用户单击元素2，则接下来会发生：</p>
<ul>
<li>单击事件首先进入捕获阶段开始（逐渐接近元素2的方向）。查看元素2的祖先元素中是否有在捕获阶段有onclick处理函数的</li>
<li>发现元素1有一个，于是doSomething2被执行</li>
<li>事件检查到目标自己（元素2），捕获阶段没有发现更多的处理函数了。事件开始进入冒泡阶段，想当然执行doSomething()，这个绑定于元素2冒泡阶段的函数。</li>
<li>事件向远离元素2的方向，查看是否有任何祖先元素在冒泡阶段绑定了一个处理函数。没有这样的情况，所以什么也没有发生</li>
</ul>
<p>相反的情况是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element1.addEventListener(<span class="string">'click'</span>,<span class="keyword">do</span>Something2,<span class="literal">false</span>)</div><div class="line"></div><div class="line">element2.addEventListener(<span class="string">'click'</span>,<span class="keyword">do</span>Something,<span class="literal">false</span>)</div></pre></td></tr></table></figure></p>
<p>现在如果用户点击元素2会发生：</p>
<ul>
<li>单击事件进入捕获阶段。查看元素2的祖先元素中是否有在捕获阶段有onclick处理函数的，结果一无所获</li>
<li>事件检查到目标自己。事件开始进入冒泡阶段，并且执行绑定于元素2冒泡阶段的函数。doSomething()</li>
<li>事件开始远离目标，检查元素2的祖先元素中是否有在冒泡阶段绑定了处理函数的</li>
<li>发现了一个，于是元素1的doSomething2()被执行</li>
</ul>
<h3 id="兼容性和传统模式"><a href="#兼容性和传统模式" class="headerlink" title="兼容性和传统模式"></a>兼容性和传统模式</h3><p>在支持w3c dom(文档对象模型) 的浏览器中，传统的事件绑定方法是<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element1.onclick = <span class="keyword">do</span>Something2;</div></pre></td></tr></table></figure></p>
<p>默认被视为在绑定于<strong>冒泡阶段</strong></p>
<h3 id="使用冒泡型事件"><a href="#使用冒泡型事件" class="headerlink" title="使用冒泡型事件"></a>使用冒泡型事件</h3><p>很少的开发人员会有意识的去使用冒泡型事件或者捕获型事件。在他们今天制作的网页中，没有必要让一个事件因为冒泡而被好几个函数处理。但是有时用户通常会很疑惑，因为在他们只点击了一次鼠标之后出现了许多种情况（多个函数被执行，因为冒泡）。而大多数情况下你还是希望你的处理函数相互独立的。当用户点击了某一个元素，发生什么，点击另一个元素，又对应发生些什么，相互独立，而不因为冒泡连锁。</p>
<h3 id="一直在发生"><a href="#一直在发生" class="headerlink" title="一直在发生"></a>一直在发生</h3><p>首先你要明白的是事件捕获或者冒泡一直在发生。如果你给整个页面文档的定义一个通用onclick处理函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.onclick = <span class="keyword">do</span>Something;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (document.captureEvents) document.captureEvents(Event.CLICK);</div></pre></td></tr></table></figure></p>
<p>//第二句话我也没有真的用过，具体可以参照<a href="http://www.java2s.com/Tutorial/JavaScript/0280__Document/documentcaptureEvents.htm" target="_blank" rel="external">这篇文章</a><br>在页面上单击任何元素的单击事件，最终会冒泡至页面最高文档层，因此触发那个通用的处理函数，除非之前一个处理函数明确的指出终止冒泡，这样才冒泡才不会传播到整个文档层面</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>因为任何事件传播终止于页面文档（这个最高层），这使默认的事件处理函数变得可能，假设你有这样一个页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">------------------------------------</div><div class="line">| document                         |</div><div class="line">|   ---------------  ------------  |</div><div class="line">|   | element1    |  | element2 |  |</div><div class="line">|   ---------------  ------------  |</div><div class="line">|                                  |</div><div class="line">------------------------------------</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element1.onclick = <span class="keyword">do</span>Something;</div><div class="line">element2.onclick = <span class="keyword">do</span>Something;</div><div class="line">document.onclick = defaultFunction;</div></pre></td></tr></table></figure>
<p>现在如果用户单击元素1或者元素2，doSomething()将被执行。如果你愿意的话，如果你不想让事件冒泡至执行defaultFunction()，你可以在这里阻止事件冒泡向上传播，。但是如果用户点击页面上的其他部位，defaultFunction()还是会被执行。这样的效果或许有时能用的上。</p>
<p>设置页面­——使处理函数有范围较大的触发面积，在“拖拽效果”脚本中是必须的。一般来说在某一个元素层上发生 mousedown事件意味着选择了这个元素，并且使它能够响应mousemove事件。虽然mousedown通常绑定于这个元素层上以避免浏览器bug，但是其他两者的事件函数的范围必须是整个页面（？）</p>
<p>记住浏览器学的第一法则（First Law of Browserology）是：一切皆有可能（anything can happen），并且是在你起码有点准备的时候。所以有可能发生的是，用户拖拽时，大幅度在页面上移动他的鼠标，脚本却不能在大幅度中做出反应，以至于鼠标也就不再停留在元素层上了</p>
<ul>
<li>如果onmouseover处理函数绑定在元素层上，这个元素层不会再对鼠标的移动有任何反应，这会让用户觉得奇怪</li>
<li>如果onmouseup处理函数绑定在元素层上，事件也不能被触发，后果是，用户想放下这个元素层后，元素层持续对鼠标移动做出反应。</li>
</ul>
<p>所以在这个例子中，事件冒泡非常的有用，因为将你的处理函数放在页面层能保证他们一直能被执行</p>
<h2 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h2><p>但是一般情况下，你会想关了所有的冒泡和捕获以保证函数之间不会打扰到对方。除此之外，如果你的文档结构相当的复杂（许多table之间相互嵌套或者诸如此类），你也会为了节省系统资源，而关闭冒泡。此时浏览器不得不检查目标元素的每一个祖先，看是否它有一个处理函数。即使一个都没有找到，刚刚的搜索同样花费不少时间</p>
<p>在微软的模型中，你必须设置事件的cancelBubble的属性为true<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.event.cancelBubble = <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>在w3c模型中你必须调用事件的stopPropagation()方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">e.stopPropagation()</div></pre></td></tr></table></figure></p>
<p>这会阻止所有冒泡向外传播。而作为跨浏览器解决方案应该这么作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="keyword">do</span>Something(e)</div><div class="line"></div><div class="line">&#123;</div><div class="line">　　　　  <span class="keyword">if</span> (!e) var e = window.event;</div><div class="line"></div><div class="line">         e.cancelBubble = <span class="literal">true</span>;</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (e.stopPropagation) e.stopPropagation();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在支持cancelBubble属性的浏览器中设置cancelBubble无伤大雅。浏览器会耸一耸肩然后创造一个这个属性。当然这也并不能真正的取消冒泡，但至少能保证这条命令是安全正确的</p>
<h3 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h3><p>像我们之前看到的一样，一个事件用target或者是srcElement属性用来表示事件究竟发生在哪个目标元素上（即用户最初点击的元素）。在我们的例子中是元素2，因为我们单击了它。</p>
<p>非常重要的是，要明白在捕获或者冒泡阶段的目标元素是不变的，它始终与元素2相关联。</p>
<p>但是假设我们绑定了以下函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element1.onclick = <span class="keyword">do</span>Something;</div><div class="line"></div><div class="line">element2.onclick = <span class="keyword">do</span>Something;</div></pre></td></tr></table></figure></p>
<p>如果用户单击元素2， doSomething()会被执行两次。但是你怎么知道哪个html元素正在响应这个事件？target/srcElement也没有给出线索，但人们总是更倾向于元素2，因为它是引起事件的原因（因为用户点击的是它）。</p>
<p>为了解决这个问题，w3c 增加了currentTarget这个属性，它就指向正在处理事件的元素：这恰是我们需要的。很不幸的是微软模型中并没有相似的属性</p>
<p>你也可以使用”this”关键字。在上面的例子中，它相当于正在处理事件的html元素，就像currentTarget。</p>
<h3 id="微软模型的问题"><a href="#微软模型的问题" class="headerlink" title="微软模型的问题"></a>微软模型的问题</h3><p>但是当你使用微软事件绑定模型时，this关键字并不相当于HTML元素。联想缺少类似currentTarget属性的微软模型（？）——按上面的代码操作的话，你这么做便意味着：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element1.attachEvent(<span class="string">'onclick'</span>,<span class="keyword">do</span>Something)</div><div class="line"></div><div class="line">element2.attachEvent(<span class="string">'onclick'</span>,<span class="keyword">do</span>Something)</div></pre></td></tr></table></figure></p>
<p>你无法确切知道哪一个HTML元素正在负责处理事件，这是微软事件绑定模型最严重的问题，对我来说，这也是我从不使用它的原因，哪怕是在开发仅供Windows下的IE的应用程序</p>
<p>本文主要参考 <a href="http://www.quirksmode.org/js/events_order.html" target="_blank" rel="external">这哥们还是姐妹</a>以及<a href="http://www.cnblogs.com/hh54188/archive/2012/02/08/2343357.html" target="_blank" rel="external">这哥们</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.supernever.com/2016/07/15/bubble/" data-id="cj0svx279000av7i8quqz908r" class="article-share-link">分享到</a><div class="tags"> <b>相关链接：</b><a href="/tags/javascript/">javascript</a><a href="/tags/js冒泡/">js冒泡</a></div><div style="margin:10px 0" clear:both><h3>打赏一杯☕️吧😝😝😝</h3><br><figure style="display:inline-block"><img src="/img/wx.png" width="200" height="200"><figcaption style="text-align:center">微信</figcaption></figure><figure style="display:inline-block"><img src="/img/zfb.png" width="200" height="200"><figcaption style="text-align:center">支付宝</figcaption></figure></div><div class="post-nav"><a href="/2016/07/19/git-最基本的操作/" class="pre">git-最基本的操作</a><a href="/2016/07/12/DOM-getBoundingClientRect/" class="next">DOM-getBoundingClientRect</a></div><div data-thread-key="2016/07/15/bubble/" data-title="bubble" data-url="http://www.supernever.com/2016/07/15/bubble/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/07/15/bubble/" data-title="bubble" data-url="http://www.supernever.com/2016/07/15/bubble/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ES6/">ES6</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/Symbol/" style="font-size: 15px;">Symbol</a> <a href="/tags/DOM-EDIT/" style="font-size: 15px;">DOM-EDIT</a> <a href="/tags/bind/" style="font-size: 15px;">bind</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/js冒泡/" style="font-size: 15px;">js冒泡</a> <a href="/tags/map/" style="font-size: 15px;">map</a> <a href="/tags/carousel/" style="font-size: 15px;">carousel</a> <a href="/tags/set/" style="font-size: 15px;">set</a> <a href="/tags/js-es6/" style="font-size: 15px;">js-es6</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/css-selector/" style="font-size: 15px;">css-selector</a> <a href="/tags/generator/" style="font-size: 15px;">generator</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/jquery-noConflict/" style="font-size: 15px;">jquery-noConflict</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/最基本操作/" style="font-size: 15px;">最基本操作</a> <a href="/tags/代码片段/" style="font-size: 15px;">代码片段</a> <a href="/tags/knockout-js/" style="font-size: 15px;">knockout.js</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/mime/" style="font-size: 15px;">mime</a> <a href="/tags/getBoundingClientRect/" style="font-size: 15px;">getBoundingClientRect</a> <a href="/tags/media-query/" style="font-size: 15px;">media-query</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/mobx/" style="font-size: 15px;">mobx</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/assert/" style="font-size: 15px;">assert</a> <a href="/tags/promise/" style="font-size: 15px;">promise</a> <a href="/tags/MySql/" style="font-size: 15px;">MySql</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/react-life/" style="font-size: 15px;">react-life</a> <a href="/tags/js-proto/" style="font-size: 15px;">js__proto__</a> <a href="/tags/reduce/" style="font-size: 15px;">reduce</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/tar/" style="font-size: 15px;">tar</a> <a href="/tags/scp/" style="font-size: 15px;">scp</a> <a href="/tags/regexp/" style="font-size: 15px;">regexp</a> <a href="/tags/小命令/" style="font-size: 15px;">小命令</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/yarn/" style="font-size: 15px;">yarn</a> <a href="/tags/webpack-howto/" style="font-size: 15px;">webpack-howto</a> <a href="/tags/模板/" style="font-size: 15px;">模板</a> <a href="/tags/可视化格式模型/" style="font-size: 15px;">可视化格式模型</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/node-assert/">node_assert</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/03/async-await/">async-await</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/mobx几个小关键词/">mobx几个小关键词</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/shell-小命令/">shell-小命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/shell-scp/">shell-scp</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/shell-tar/">shell-tar</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/mysql基本命令/">mysql基本命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/01/decorator/">decorator</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/24/Symbol-iterator/">Symbol.iterator</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/24/模板字符串/">模板字符串</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 相关链接</i></div><a href="http://www.github.com/supernever" title="github" target="_blank" class="links-github"></a><a href="http://weibo.com/u/3282385447?refer_flag=1001030102_" title="weibo" target="_blank" class="links-weibo"></a><a href="https://www.zhihu.com/people/supernever-65/activities" title="zhihu" target="_blank" class="links-zhihu"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018. All Rights Reserved版权所有
 京ICP备17005055号-1</div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'supernever'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','true','auto');ga('send','pageview');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>